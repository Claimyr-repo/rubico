/**
 * rubico v1.6.6
 * https://github.com/a-synchronous/rubico
 * (c) 2019-2020 Richard Tong
 * rubico may be freely distributed under the MIT license.
 */
const symbolIterator=Symbol.iterator,MappingIterator=(r,n)=>({toString:()=>"[object MappingIterator]",[symbolIterator](){return this},next(){const t=r.next();return t.done?t:{value:n(t.value),done:!1}}}),NextIteration=r=>({value:r,done:!1}),isPromise=r=>null!=r&&"function"==typeof r.then,symbolAsyncIterator=Symbol.asyncIterator,MappingAsyncIterator=(r,n)=>({[symbolAsyncIterator](){return this},async next(){const t=await r.next();if(t.done)return t;const e=n(t.value);return isPromise(e)?e.then(NextIteration):{value:e,done:!1}}}),isArray=Array.isArray,isObject=r=>null!=r&&("object"==typeof r||"function"==typeof r),objectProto=Object.prototype,nativeObjectToString=objectProto.toString,objectToString=r=>nativeObjectToString.call(r),generatorFunctionTag="[object GeneratorFunction]",isGeneratorFunction=r=>objectToString(r)==generatorFunctionTag,asyncGeneratorFunctionTag="[object AsyncGeneratorFunction]",isAsyncGeneratorFunction=r=>objectToString(r)==asyncGeneratorFunctionTag,promiseAll=Promise.all.bind(Promise),arrayMap=function(r,n){const t=r.length,e=Array(t);let o=-1,c=!1;for(;++o<t;){const t=n(r[o]);isPromise(t)&&(c=!0),e[o]=t}return c?promiseAll(e):e},generatorFunctionMap=(r,n)=>function*(...t){for(const e of r(...t))yield n(e)},asyncGeneratorFunctionMap=function(r,n){return async function*(...t){for await(const e of r(...t))yield n(e)}},__=Symbol.for("placeholder"),curry2ResolveArg0=(r,n)=>function(t){return r(t,n)},curry2ResolveArg1=(r,n)=>function(t){return r(n,t)},curry2=function(r,n,t){return n==__?curry2ResolveArg0(r,t):curry2ResolveArg1(r,n)},reducerMap=(r,n)=>function(t,e){const o=n(e);return isPromise(o)?o.then((c=r,i=__,(a=t)==__?curry2ResolveArg0(c,i):curry2ResolveArg1(c,a))):r(t,o);var c,a,i},curry3ResolveArg0=(r,n,t)=>function(e){return r(e,n,t)},curry3ResolveArg1=(r,n,t)=>function(e){return r(n,e,t)},curry3ResolveArg2=(r,n,t)=>function(e){return r(n,t,e)},curry3=function(r,n,t,e){return n==__?curry3ResolveArg0(r,t,e):t==__?curry3ResolveArg1(r,n,e):curry3ResolveArg2(r,n,t)},callPropUnary=(r,n,t)=>r[n](t),stringMap=function(r,n){const t=arrayMap(r,n);return isPromise(t)?t.then(curry3(callPropUnary,__,"join","")):t.join("")},always=r=>function(){return r},setMap=function(r,n){const t=new Set,e=[];for(const o of r){const r=n(o);isPromise(r)?e.push(r.then(curry3(callPropUnary,t,"add",__))):t.add(r)}return 0==e.length?t:promiseAll(e).then(always(t))},curry4ResolveArg0=(r,n,t,e)=>function(o){return r(o,n,t,e)},curry4ResolveArg1=(r,n,t,e)=>function(o){return r(n,o,t,e)},curry4ResolveArg2=(r,n,t,e)=>function(o){return r(n,t,o,e)},curry4ResolveArg3=(r,n,t,e)=>function(o){return r(n,t,e,o)},curry4=function(r,n,t,e,o){return n==__?curry4ResolveArg0(r,t,e,o):t==__?curry4ResolveArg1(r,n,e,o):e==__?curry4ResolveArg2(r,n,t,o):curry4ResolveArg3(r,n,t,e)},callPropBinary=(r,n,t,e)=>r[n](t,e),mapMap=function(r,n){const t=new Map,e=[];for(const[o,c]of r){const r=n(c);isPromise(r)?e.push(r.then(curry4(callPropBinary,t,"set",o,__))):t.set(o,r)}return 0==e.length?t:promiseAll(e).then(always(t))},promiseObjectAllExecutor=r=>function(n){const t={};let e=0;for(const o in r){const c=r[o];isPromise(c)?(e+=1,c.then((r=>function(o){t[r]=o,e-=1,0==e&&n(t)})(o))):t[o]=c}0==e&&n(t)},promiseObjectAll=r=>new Promise(promiseObjectAllExecutor(r)),objectMap=function(r,n){const t={};let e=!1;for(const o in r){const c=n(r[o]);isPromise(c)&&(e=!0),t[o]=c}return e?promiseObjectAll(t):t},funcConcat=(r,n)=>function(...t){const e=r(...t);return isPromise(e)?e.then(n):n(e)},objectSet=function(r,n,t){return r[n]=t,r},arrayMapSeriesAsync=async function(r,n,t,e){const o=r.length;for(;++e<o;){const o=n(r[e]);t[e]=isPromise(o)?await o:o}return t},arrayMapSeries=function(r,n){const t=r.length,e=Array(t);let o=-1;for(;++o<t;){const t=n(r[o]);if(isPromise(t))return t.then(funcConcat(curry3(objectSet,e,o,__),curry4(arrayMapSeriesAsync,r,n,__,o)));e[o]=t}return e},tapSync=r=>function(...n){return r(...n),n[0]},promiseRace=Promise.race.bind(Promise),arrayMapPoolAsync=async function(r,n,t,e,o,c){const a=r.length;for(;++o<a;){c.size>=t&&await promiseRace(c);const a=n(r[o]);if(isPromise(a)){const r=a.then(tapSync((()=>c.delete(r))));c.add(r),e[o]=r}else e[o]=a}return promiseAll(e)},arrayMapPool=function(r,n,t){const e=r.length,o=Array(e);let c=-1;for(;++c<e;){const e=n(r[c]);if(isPromise(e)){const a=new Set,i=e.then(tapSync((()=>a.delete(i))));return a.add(i),o[c]=i,arrayMapPoolAsync(r,n,t,o,c,a)}o[c]=e}return o},arrayMapWithIndex=function(r,n){const t=r.length,e=Array(t);let o=-1,c=!1;for(;++o<t;){const t=n(r[o],o,r);isPromise(t)&&(c=!0),e[o]=t}return c?promiseAll(e):e},hasOwnProperty=Object.prototype.hasOwnProperty,hasOwn=(r,n)=>hasOwnProperty.call(r,n),objectMapOwn=function(r,n){const t={};let e=!1;for(const o in r)if(hasOwn(r,o)){const c=n(r[o]);isPromise(c)&&(e=!0),t[o]=c}return e?promiseObjectAll(t):t},map=r=>function(n){return isArray(n)?arrayMap(n,r):"function"==typeof n?isGeneratorFunction(n)?generatorFunctionMap(n,r):isAsyncGeneratorFunction(n)?asyncGeneratorFunctionMap(n,r):reducerMap(n,r):null==n?n:"function"==typeof n.then?n.then(r):"function"==typeof n.map?n.map(r):"function"==typeof n.next?symbolIterator in n?MappingIterator(n,r):MappingAsyncIterator(n,r):"string"==typeof n||n.constructor==String?stringMap(n,r):n.constructor==Set?setMap(n,r):n.constructor==Map?mapMap(n,r):n.constructor==Object?objectMap(n,r):r(n)};map.series=r=>function(n){if(isArray(n))return arrayMapSeries(n,r);throw new TypeError(n+" is not an Array")},map.pool=(r,n)=>function(t){if(isArray(t))return arrayMapPool(t,n,r);throw new TypeError(t+" is not an Array")},map.withIndex=r=>function(n){if(isArray(n))return arrayMapWithIndex(n,r);throw new TypeError(n+" is not an Array")},map.own=r=>function(n){if(isObject(n)&&!isArray(n))return objectMapOwn(n,r);throw new TypeError(n+" is not an Object")};export default map;
