/**
 * rubico v1.6.7
 * https://github.com/a-synchronous/rubico
 * (c) 2019-2020 Richard Tong
 * rubico may be freely distributed under the MIT license.
 */
const isArray=Array.isArray,memoizeCappedUnary=function(t,e){const i=new Map,n=function(n){if(i.has(n))return i.get(n);const r=t(n);return i.set(n,r),i.size>e&&i.clear(),r};return n.cache=i,n},pathStringSplitRegex=/[.|[|\]]+/,pathStringSplit=function(t){const e=t.length-1,i="["==t[0],n="]"==t[e];return i&&n?t.slice(1,e).split(pathStringSplitRegex):i?t.slice(1).split(pathStringSplitRegex):n?t.slice(0,e).split(pathStringSplitRegex):t.split(pathStringSplitRegex)},memoizedCappedPathStringSplit=memoizeCappedUnary(pathStringSplit,500),pathToArray=t=>isArray(t)?t:"string"==typeof t?memoizedCappedPathStringSplit(t):[t],getByPath=function(t,e){const i=pathToArray(e),n=i.length;let r=-1,p=t;for(;++r<n;)if(p=p[i[r]],null==p)return;return p},get=(t,e)=>function(i){const n=null==i?void 0:getByPath(i,t);return void 0===n?"function"==typeof e?e(i):e:n};export default get;
