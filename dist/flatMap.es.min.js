/**
 * rubico v1.6.8
 * https://github.com/a-synchronous/rubico
 * (c) 2019-2020 Richard Tong
 * rubico may be freely distributed under the MIT license.
 */
const isArray=Array.isArray,objectValues=Object.values,objectProto=Object.prototype,nativeObjectToString=objectProto.toString,objectToString=t=>nativeObjectToString.call(t),generatorFunctionTag="[object GeneratorFunction]",isGeneratorFunction=t=>objectToString(t)==generatorFunctionTag,asyncGeneratorFunctionTag="[object AsyncGeneratorFunction]",isAsyncGeneratorFunction=t=>objectToString(t)==asyncGeneratorFunctionTag,__=Symbol.for("placeholder"),curry3ResolveArg0=(t,r,e)=>function(n){return t(n,r,e)},curry3ResolveArg1=(t,r,e)=>function(n){return t(r,n,e)},curry3ResolveArg2=(t,r,e)=>function(n){return t(r,e,n)},curry3=function(t,r,e,n){return r==__?curry3ResolveArg0(t,e,n):e==__?curry3ResolveArg1(t,r,n):curry3ResolveArg2(t,r,e)},isPromise=t=>null!=t&&"function"==typeof t.then,iteratorReduceAsync=async function(t,r,e){let n=t.next();if(n.done)return e;for(;!n.done;)e=r(e,n.value),isPromise(e)&&(e=await e),n=t.next();return e},iteratorReduce=function(t,r,e){let n=t.next();if(n.done)return e;for(void 0===e&&(e=n.value,n=t.next());!n.done;){if(e=r(e,n.value),isPromise(e))return e.then(curry3(iteratorReduceAsync,t,r,__));n=t.next()}return e},asyncIteratorReduce=async function(t,r,e){let n=await t.next();if(n.done)return e;for(void 0===e&&(e=n.value,n=await t.next());!n.done;)e=await r(e,n.value),n=await t.next();return e},symbolIterator=Symbol.iterator,symbolAsyncIterator=Symbol.asyncIterator,_curryArity=(t,r,e)=>function(...n){const o=e.length,c=n.length,s=[];let i=-1,a=-1,u=0;for(;++i<o;){const o=e[i];if(o==__&&(a+=1)<c){const t=n[a];t==__&&(u+=1),s.push(t)}else s.push(o);if(s.length==t)return 0==u?r(...s):curryArity(t,r,s)}for(;++a<c;){const e=n[a];if(e==__&&(u+=1),s.push(e),s.length==t)return 0==u?r(...s):curryArity(t,r,s)}return curryArity(t,r,s)},curryArity=function(t,r,e){const n=e.length;if(n<t)return _curryArity(t,r,e);let o=-1;for(;++o<n;){if(e[o]==__)return _curryArity(t,r,e)}return r(...e)},curry2ResolveArg0=(t,r)=>function(e){return t(e,r)},curry2ResolveArg1=(t,r)=>function(e){return t(r,e)},curry2=function(t,r,e){return r==__?curry2ResolveArg0(t,e):curry2ResolveArg1(t,r)},curryArgs3ResolveArgs0=(t,r,e)=>function(...n){return t(n,r,e)},curryArgs3ResolveArgs1=(t,r,e)=>function(...n){return t(r,n,e)},curryArgs3ResolveArgs2=(t,r,e)=>function(...n){return t(r,e,n)},curryArgs3=function(t,r,e,n){return r==__?curryArgs3ResolveArgs0(t,e,n):e==__?curryArgs3ResolveArgs1(t,r,n):curryArgs3ResolveArgs2(t,r,e)},curry4ResolveArg0=(t,r,e,n)=>function(o){return t(o,r,e,n)},curry4ResolveArg1=(t,r,e,n)=>function(o){return t(r,o,e,n)},curry4ResolveArg2=(t,r,e,n)=>function(o){return t(r,e,o,n)},curry4ResolveArg3=(t,r,e,n)=>function(o){return t(r,e,n,o)},curry4=function(t,r,e,n,o){return r==__?curry4ResolveArg0(t,e,n,o):e==__?curry4ResolveArg1(t,r,n,o):n==__?curry4ResolveArg2(t,r,e,o):curry4ResolveArg3(t,r,e,n)},arrayReduceAsync=async function(t,r,e,n){const o=t.length;for(;++n<o;)e=r(e,t[n]),isPromise(e)&&(e=await e);return e},arrayReduce=function(t,r,e){const n=t.length;let o=-1;for(void 0===e&&(e=t[++o]);++o<n;)if(e=r(e,t[o]),isPromise(e))return e.then((c=arrayReduceAsync,i=r,a=__,u=o,(s=t)==__?curry4ResolveArg0(c,i,a,u):i==__?curry4ResolveArg1(c,s,a,u):a==__?curry4ResolveArg2(c,s,i,u):curry4ResolveArg3(c,s,i,a)));var c,s,i,a,u;return e},funcConcatSync=(t,r)=>function(...e){return r(t(...e))},generatorFunctionReduce=(t,r,e)=>funcConcatSync(t,curry3(iteratorReduce,__,r,e)),asyncGeneratorFunctionReduce=(t,r,e)=>funcConcatSync(t,curry3(asyncIteratorReduce,__,r,e)),reducerConcat=(t,r)=>function(e,n){const o=t(e,n);return isPromise(o)?o.then(curry2(r,__,n)):r(o,n)},genericReduce=function(t,r,e){const n=t[0];return isArray(n)?arrayReduce(n,r,e):"function"==typeof n?isGeneratorFunction(n)?generatorFunctionReduce(n,r,e):isAsyncGeneratorFunction(n)?asyncGeneratorFunctionReduce(n,r,e):curryArgs3(genericReduce,__,1==t.length?reducerConcat(r,n):t.reduce(reducerConcat,r),e):null==n?void 0===e?curry2(r,n,__):r(e,n):"function"==typeof n[symbolIterator]?iteratorReduce(n[symbolIterator](),r,e):"function"==typeof n[symbolAsyncIterator]?asyncIteratorReduce(n[symbolAsyncIterator](),r,e):"function"==typeof n.reduce?n.reduce(r,e):"function"==typeof n.chain?n.chain(curry2(r,e,__)):"function"==typeof n.flatMap?n.flatMap(curry2(r,e,__)):n.constructor==Object?arrayReduce(objectValues(n),r,e):void 0===e?curry2(r,n,__):r(e,n)},arrayPush=function(t,r){return t.push(r),t},FlatMappingIterator=function(t,r){let e=[],n=0;return{[symbolIterator](){return this},next(){if(n<e.length){const t=e[n];return n+=1,{value:t,done:!1}}const o=t.next();if(o.done)return o;const c=genericReduce([r(o.value)],arrayPush,[]);return c.length>1&&(e=c,n=1),{value:c[0],done:!1}}}},promiseRace=Promise.race.bind(Promise),FlatMappingAsyncIterator=function(t,r){const e=[],n=new Set;let o=0;return{[symbolAsyncIterator](){return this},toString:()=>"[object FlatMappingAsyncIterator]",async next(){if(o<e.length){const t=e[o];return delete e[o],o+=1,{value:t,done:!1}}const c=await t.next();if(c.done)return 0==n.size?c:(await promiseRace(n),this.next());let s=r(c.value);isPromise(s)&&(s=await s);const i=genericReduce([s],arrayPush,e);if(isPromise(i)){const t=i.then((()=>n.delete(t)));n.add(t)}return this.next()}}},isBinary=ArrayBuffer.isView,always=t=>function(){return t},getArg1=(t,r)=>r,identity=t=>t,promiseAll=Promise.all.bind(Promise),asyncIteratorForEach=async function(t,r){const e=[];for await(const n of t){const t=r(n);isPromise(t)&&e.push(t)}return 0==e.length?t:promiseAll(e).then(always(t))},arrayFlatten=function(t){const r=t.length,e=[],n=[];let o=-1;for(;++o<r;){const r=t[o];if(isArray(r)){const t=r.length;let e=-1;for(;++e<t;)n.push(r[e])}else if(null==r)n.push(r);else if("function"==typeof r.then)e.push(r.then(curry2(arrayPush,n,__)));else if("function"==typeof r[symbolIterator])for(const t of r)n.push(t);else if("function"==typeof r[symbolAsyncIterator])e.push(asyncIteratorForEach(r[symbolAsyncIterator](),curry2(arrayPush,n,__)));else if("function"==typeof r.chain){const t=r.chain(identity);isPromise(t)?e.push(t.then(curry2(arrayPush,n,__))):n.push(t)}else if("function"==typeof r.flatMap){const t=r.flatMap(identity);isPromise(t)?e.push(t.then(curry2(arrayPush,n,__))):n.push(t)}else if("function"==typeof r.reduce){const t=r.reduce(funcConcatSync(getArg1,curry2(arrayPush,n,__)),null);isPromise(t)&&e.push(t)}else if(r.constructor==Object)for(const t in r)n.push(r[t]);else n.push(r)}return 0==e.length?n:promiseAll(e).then(always(n))},arrayMap=function(t,r){const e=t.length,n=Array(e);let o=-1,c=!1;for(;++o<e;){const e=r(t[o]);isPromise(e)&&(c=!0),n[o]=e}return c?promiseAll(n):n},arrayFlatMap=function(t,r){const e=arrayMap(t,r);return isPromise(e)?e.then(arrayFlatten):arrayFlatten(e)},promiseObjectAllExecutor=t=>function(r){const e={};let n=0;for(const o in t){const c=t[o];isPromise(c)?(n+=1,c.then((t=>function(o){e[t]=o,n-=1,0==n&&r(e)})(o))):e[o]=c}0==n&&r(e)},promiseObjectAll=t=>new Promise(promiseObjectAllExecutor(t)),objectMap=function(t,r){const e={};let n=!1;for(const o in t){const c=r(t[o]);isPromise(c)&&(n=!0),e[o]=c}return n?promiseObjectAll(e):e},objectAssign=Object.assign,objectFlatten=function(t){const r=[],e={},n=curry2(objectAssign,e,__),o=funcConcatSync(getArg1,n);for(const c in t){const s=t[c];if(null!=s)if("function"==typeof s[symbolIterator])for(const t of s)objectAssign(e,t);else if("function"==typeof s[symbolAsyncIterator])r.push(asyncIteratorForEach(s[symbolAsyncIterator](),n));else if("function"==typeof s.chain){const t=s.chain(identity);isPromise(t)?r.push(t.then(n)):objectAssign(e,t)}else if("function"==typeof s.flatMap){const t=s.flatMap(identity);isPromise(t)?r.push(t.then(n)):n(t)}else if("function"==typeof s.reduce){const t=s.reduce(o,null);isPromise(t)&&r.push(t)}else objectAssign(e,s)}return 0==r.length?e:promiseAll(r).then((()=>e))},objectFlatMap=function(t,r){const e=objectMap(t,r);return isPromise(e)?e.then(objectFlatten):objectFlatten(e)},callPropUnary=(t,r,e)=>t[r](e),setMap=function(t,r){const e=new Set,n=[];for(const o of t){const t=r(o);isPromise(t)?n.push(t.then(curry3(callPropUnary,e,"add",__))):e.add(t)}return 0==n.length?e:promiseAll(n).then(always(e))},setFlatten=function(t){t.size;const r=[],e=new Set,n=(t,r)=>e.add(r),o=curry3(callPropUnary,e,"add",__);for(const c of t)if(isArray(c)){const t=c.length;let r=-1;for(;++r<t;)e.add(c[r])}else if(null==c)e.add(c);else if("function"==typeof c[symbolIterator])for(const t of c)e.add(t);else if("function"==typeof c[symbolAsyncIterator])r.push(asyncIteratorForEach(c[symbolAsyncIterator](),o));else if("function"==typeof c.chain){const t=c.chain(identity);isPromise(t)?r.push(t.then(o)):e.add(t)}else if("function"==typeof c.flatMap){const t=c.flatMap(identity);isPromise(t)?r.push(t.then(o)):e.add(t)}else if("function"==typeof c.reduce){const t=c.reduce(n,null);isPromise(t)&&r.push(t)}else if(c.constructor==Object)for(const t in c)e.add(c[t]);else e.add(c);return 0==r.length?e:promiseAll(r).then((()=>e))},setFlatMap=function(t,r){const e=setMap(t,r);return isPromise(e)?e.then(setFlatten):setFlatten(e)},funcConcat=(t,r)=>function(...e){const n=t(...e);return isPromise(n)?n.then(r):r(n)},arrayJoin=(t,r)=>t.join(r),arrayFlattenToString=funcConcat(arrayFlatten,curry2(arrayJoin,__,"")),stringFlatMap=function(t,r){const e=arrayMap(t,r);return isPromise(e)?e.then(arrayFlattenToString):arrayFlattenToString(e)},streamWrite=function(t,r,e,n){return t.write(r,e,n),t},streamFlatExtend=async function(t,r){const e=curry2(streamWrite,t,__),n=funcConcatSync(getArg1,e),o=[];if(isArray(r)){const e=r.length;let n=-1;for(;++n<e;)t.write(r[n])}else if(null==r)t.write(r);else if("function"==typeof r[symbolIterator])for(const e of r)t.write(e);else if("function"==typeof r[symbolAsyncIterator])o.push(asyncIteratorForEach(r[symbolAsyncIterator](),e));else if("function"==typeof r.chain){const n=r.chain(identity);isPromise(n)?o.push(n.then(e)):t.write(n)}else if("function"==typeof r.flatMap){const n=r.flatMap(identity);isPromise(n)?o.push(n.then(e)):t.write(n)}else if("function"==typeof r.reduce){const t=r.reduce(n,null);isPromise(t)&&o.push(t)}else if(r.constructor==Object)for(const e in r)t.write(r[e]);else t.write(r);return 0==o.length?t:promiseAll(o).then(always(t))},streamFlatMap=async function(t,r){const e=new Set;for await(const n of t){const o=r(n);if(isPromise(o)){const r=o.then(curry2(streamFlatExtend,t,__)).then((()=>e.delete(r)));e.add(r)}else{const r=streamFlatExtend(t,o);if(isPromise(r)){const t=r.then((()=>e.delete(t)));e.add(t)}}}return await promiseAll(e),t},_binaryExtend=function(t,r){const e=t.length,n=new t.constructor(e+r.length);return n.set(t),n.set(r,e),n},binaryExtend=function(t,r){return isArray(r)||isBinary(r)?_binaryExtend(t,r):_binaryExtend(t,[r])},globalThisHasBuffer="function"==typeof Buffer,noop=function(){},bufferAlloc=globalThisHasBuffer?Buffer.alloc:noop,arrayJoinToBinary=function(t,r){const e=t.length;let n=-1,o=r;for(;++n<e;)o=binaryExtend(o,t[n]);return o},arrayFlattenToBinary=function(t,r){const e=arrayFlatten(t);return isPromise(e)?e.then(curry2(arrayJoinToBinary,__,r)):arrayJoinToBinary(e,r)},binaryFlatMap=function(t,r){const e=arrayMap(t,r),n=globalThisHasBuffer&&t.constructor==Buffer?bufferAlloc(0):new t.constructor(0);return isPromise(e)?e.then(curry2(arrayFlattenToBinary,__,n)):arrayFlattenToBinary(e,n)},reducerFlatMap=(t,r)=>function(e,n){const o=r(n);return isPromise(o)?o.then(curryArgs3(genericReduce,__,t,e)):genericReduce([o],t,e)},generatorFunctionFlatMap=(t,r)=>function*(...e){yield*FlatMappingIterator(t(...e),r)},asyncGeneratorFunctionFlatMap=(t,r)=>async function*(...e){yield*FlatMappingAsyncIterator(t(...e),r)},flatMap=t=>function(r){if(isArray(r))return arrayFlatMap(r,t);if("function"==typeof r)return isGeneratorFunction(r)?generatorFunctionFlatMap(r,t):isAsyncGeneratorFunction(r)?asyncGeneratorFunctionFlatMap(r,t):reducerFlatMap(r,t);if(isBinary(r))return binaryFlatMap(r,t);if(null==r)return t(r);if("function"==typeof r.then)return r.then(t);if("function"==typeof r.next)return symbolIterator in r?FlatMappingIterator(r,t):FlatMappingAsyncIterator(r,t);if("function"==typeof r.chain)return r.chain(t);if("function"==typeof r.flatMap)return r.flatMap(t);if("function"==typeof r[symbolAsyncIterator]&&"function"==typeof r.write)return streamFlatMap(r,t);const e=r.constructor;return e==Object?objectFlatMap(r,t):e==Set?setFlatMap(r,t):"string"==typeof r||e==String?stringFlatMap(r,t):t(r)};export default flatMap;
