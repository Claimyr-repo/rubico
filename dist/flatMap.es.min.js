/**
 * rubico v1.6.20
 * https://github.com/a-synchronous/rubico
 * (c) 2019-2020 Richard Tong
 * rubico may be freely distributed under the MIT license.
 */
const isArray=Array.isArray,objectValues=Object.values,objectProto=Object.prototype,nativeObjectToString=objectProto.toString,objectToString=t=>nativeObjectToString.call(t),generatorFunctionTag="[object GeneratorFunction]",isGeneratorFunction=t=>objectToString(t)==generatorFunctionTag,asyncGeneratorFunctionTag="[object AsyncGeneratorFunction]",isAsyncGeneratorFunction=t=>objectToString(t)==asyncGeneratorFunctionTag,__=Symbol.for("placeholder"),curry3ResolveArg0=(t,e,r)=>function(n){return t(n,e,r)},curry3ResolveArg1=(t,e,r)=>function(n){return t(e,n,r)},curry3ResolveArg2=(t,e,r)=>function(n){return t(e,r,n)},curry3=function(t,e,r,n){return e==__?curry3ResolveArg0(t,r,n):r==__?curry3ResolveArg1(t,e,n):curry3ResolveArg2(t,e,r)},isPromise=t=>null!=t&&"function"==typeof t.then,iteratorReduceAsync=async function(t,e,r){let n=t.next();if(n.done)return r;for(;!n.done;)r=e(r,n.value),isPromise(r)&&(r=await r),n=t.next();return r},iteratorReduce=function(t,e,r){let n=t.next();if(n.done)return r;for(void 0===r&&(r=n.value,n=t.next());!n.done;){if(r=e(r,n.value),isPromise(r))return r.then(curry3(iteratorReduceAsync,t,e,__));n=t.next()}return r},asyncIteratorReduce=async function(t,e,r){let n=await t.next();if(n.done)return r;for(void 0===r&&(r=n.value,n=await t.next());!n.done;)r=await e(r,n.value),n=await t.next();return r},symbolIterator=Symbol.iterator,symbolAsyncIterator=Symbol.asyncIterator,curry2ResolveArg0=(t,e)=>function(r){return t(r,e)},curry2ResolveArg1=(t,e)=>function(r){return t(e,r)},curry2=function(t,e,r){return e==__?curry2ResolveArg0(t,r):curry2ResolveArg1(t,e)},curryArgs3ResolveArgs0=(t,e,r)=>function(...n){return t(n,e,r)},curryArgs3ResolveArgs1=(t,e,r)=>function(...n){return t(e,n,r)},curryArgs3ResolveArgs2=(t,e,r)=>function(...n){return t(e,r,n)},curryArgs3=function(t,e,r,n){return e==__?curryArgs3ResolveArgs0(t,r,n):r==__?curryArgs3ResolveArgs1(t,e,n):curryArgs3ResolveArgs2(t,e,r)},curry4ResolveArg0=(t,e,r,n)=>function(o){return t(o,e,r,n)},curry4ResolveArg1=(t,e,r,n)=>function(o){return t(e,o,r,n)},curry4ResolveArg2=(t,e,r,n)=>function(o){return t(e,r,o,n)},curry4ResolveArg3=(t,e,r,n)=>function(o){return t(e,r,n,o)},curry4=function(t,e,r,n,o){return e==__?curry4ResolveArg0(t,r,n,o):r==__?curry4ResolveArg1(t,e,n,o):n==__?curry4ResolveArg2(t,e,r,o):curry4ResolveArg3(t,e,r,n)},arrayReduceAsync=async function(t,e,r,n){const o=t.length;for(;++n<o;)r=e(r,t[n]),isPromise(r)&&(r=await r);return r},arrayReduce=function(t,e,r){const n=t.length;let o=-1;for(void 0===r&&(r=t[++o]);++o<n;)if(r=e(r,t[o]),isPromise(r))return r.then((c=arrayReduceAsync,i=e,a=__,u=o,(s=t)==__?curry4ResolveArg0(c,i,a,u):i==__?curry4ResolveArg1(c,s,a,u):a==__?curry4ResolveArg2(c,s,i,u):curry4ResolveArg3(c,s,i,a)));var c,s,i,a,u;return r},funcConcatSync=(t,e)=>function(...r){return e(t(...r))},generatorFunctionReduce=(t,e,r)=>funcConcatSync(t,curry3(iteratorReduce,__,e,r)),asyncGeneratorFunctionReduce=(t,e,r)=>funcConcatSync(t,curry3(asyncIteratorReduce,__,e,r)),reducerConcat=(t,e)=>function(r,n){const o=t(r,n);return isPromise(o)?o.then(curry2(e,__,n)):e(o,n)},genericReduce=function(t,e,r){const n=t[0];return isArray(n)?arrayReduce(n,e,r):"function"==typeof n?isGeneratorFunction(n)?generatorFunctionReduce(n,e,r):isAsyncGeneratorFunction(n)?asyncGeneratorFunctionReduce(n,e,r):curryArgs3(genericReduce,__,1==t.length?reducerConcat(e,n):t.reduce(reducerConcat,e),r):null==n?void 0===r?curry2(e,n,__):e(r,n):"function"==typeof n[symbolIterator]?iteratorReduce(n[symbolIterator](),e,r):"function"==typeof n[symbolAsyncIterator]?asyncIteratorReduce(n[symbolAsyncIterator](),e,r):"function"==typeof n.reduce?n.reduce(e,r):"function"==typeof n.chain?n.chain(curry2(e,r,__)):"function"==typeof n.flatMap?n.flatMap(curry2(e,r,__)):n.constructor==Object?arrayReduce(objectValues(n),e,r):void 0===r?curry2(e,n,__):e(r,n)},arrayPush=function(t,e){return t.push(e),t},FlatMappingIterator=function(t,e){let r=[],n=0;return{[symbolIterator](){return this},next(){if(n<r.length){const t=r[n];return n+=1,{value:t,done:!1}}const o=t.next();if(o.done)return o;const c=genericReduce([e(o.value)],arrayPush,[]);return c.length>1&&(r=c,n=1),{value:c[0],done:!1}}}},FlatMappingAsyncIterator=function(t,e){const r=[],n=new Set;return{[symbolAsyncIterator](){return this},toString:()=>"[object FlatMappingAsyncIterator]",async next(){if(r.length>0)return{value:r.shift(),done:!1};const{value:o,done:c}=await t.next();if(c){for(;n.size>0;)if(await new Promise((t=>setTimeout(t,25))),r.length>0)return{value:r.shift(),done:!1};return{value:void 0,done:!0}}const s=e(o);if(isPromise(s)){const t=s.then(curryArgs3(genericReduce,__,arrayPush,r)).then((()=>n.delete(t)));n.add(t)}else{const t=genericReduce([s],arrayPush,r);if(r.length>0)return{value:r.shift(),done:!1};if(isPromise(t)){const e=t.then((()=>n.delete(e)));n.add(e)}}for(;n.size>0;)if(await new Promise((t=>setTimeout(t,25))),r.length>0)return{value:r.shift(),done:!1};return{value:void 0,done:!0}}}},isBinary=ArrayBuffer.isView,always=t=>function(){return t},getArg1=(t,e)=>e,identity=t=>t,promiseAll=Promise.all.bind(Promise),asyncIteratorForEach=async function(t,e){const r=[];for await(const n of t){const t=e(n);isPromise(t)&&r.push(t)}return 0==r.length?t:promiseAll(r).then(always(t))},arrayFlatten=function(t){const e=t.length,r=[],n=[];let o=-1;for(;++o<e;){const e=t[o];if(isArray(e)){const t=e.length;let r=-1;for(;++r<t;)n.push(e[r])}else if(null==e)n.push(e);else if("function"==typeof e.then)r.push(e.then(curry2(arrayPush,n,__)));else if("function"==typeof e[symbolIterator])for(const t of e)n.push(t);else if("function"==typeof e[symbolAsyncIterator])r.push(asyncIteratorForEach(e[symbolAsyncIterator](),curry2(arrayPush,n,__)));else if("function"==typeof e.chain){const t=e.chain(identity);isPromise(t)?r.push(t.then(curry2(arrayPush,n,__))):n.push(t)}else if("function"==typeof e.flatMap){const t=e.flatMap(identity);isPromise(t)?r.push(t.then(curry2(arrayPush,n,__))):n.push(t)}else if("function"==typeof e.reduce){const t=e.reduce(funcConcatSync(getArg1,curry2(arrayPush,n,__)),null);isPromise(t)&&r.push(t)}else if(e.constructor==Object)for(const t in e)n.push(e[t]);else n.push(e)}return 0==r.length?n:promiseAll(r).then(always(n))},arrayMap=function(t,e){const r=t.length,n=Array(r);let o=-1,c=!1;for(;++o<r;){const r=e(t[o]);isPromise(r)&&(c=!0),n[o]=r}return c?promiseAll(n):n},arrayFlatMap=function(t,e){const r=arrayMap(t,e);return isPromise(r)?r.then(arrayFlatten):arrayFlatten(r)},promiseObjectAllExecutor=t=>function(e){const r={};let n=0;for(const o in t){const c=t[o];isPromise(c)?(n+=1,c.then((t=>function(o){r[t]=o,n-=1,0==n&&e(r)})(o))):r[o]=c}0==n&&e(r)},promiseObjectAll=t=>new Promise(promiseObjectAllExecutor(t)),objectMap=function(t,e){const r={};let n=!1;for(const o in t){const c=e(t[o]);isPromise(c)&&(n=!0),r[o]=c}return n?promiseObjectAll(r):r},objectAssign=Object.assign,objectFlatten=function(t){const e=[],r={},n=curry2(objectAssign,r,__),o=funcConcatSync(getArg1,n);for(const c in t){const s=t[c];if(null!=s)if("function"==typeof s[symbolIterator])for(const t of s)objectAssign(r,t);else if("function"==typeof s[symbolAsyncIterator])e.push(asyncIteratorForEach(s[symbolAsyncIterator](),n));else if("function"==typeof s.chain){const t=s.chain(identity);isPromise(t)?e.push(t.then(n)):objectAssign(r,t)}else if("function"==typeof s.flatMap){const t=s.flatMap(identity);isPromise(t)?e.push(t.then(n)):n(t)}else if("function"==typeof s.reduce){const t=s.reduce(o,null);isPromise(t)&&e.push(t)}else objectAssign(r,s)}return 0==e.length?r:promiseAll(e).then((()=>r))},objectFlatMap=function(t,e){const r=objectMap(t,e);return isPromise(r)?r.then(objectFlatten):objectFlatten(r)},callPropUnary=(t,e,r)=>t[e](r),setMap=function(t,e){const r=new Set,n=[];for(const o of t){const t=e(o);isPromise(t)?n.push(t.then(curry3(callPropUnary,r,"add",__))):r.add(t)}return 0==n.length?r:promiseAll(n).then(always(r))},setFlatten=function(t){t.size;const e=[],r=new Set,n=(t,e)=>r.add(e),o=curry3(callPropUnary,r,"add",__);for(const c of t)if(isArray(c)){const t=c.length;let e=-1;for(;++e<t;)r.add(c[e])}else if(null==c)r.add(c);else if("function"==typeof c[symbolIterator])for(const t of c)r.add(t);else if("function"==typeof c[symbolAsyncIterator])e.push(asyncIteratorForEach(c[symbolAsyncIterator](),o));else if("function"==typeof c.chain){const t=c.chain(identity);isPromise(t)?e.push(t.then(o)):r.add(t)}else if("function"==typeof c.flatMap){const t=c.flatMap(identity);isPromise(t)?e.push(t.then(o)):r.add(t)}else if("function"==typeof c.reduce){const t=c.reduce(n,null);isPromise(t)&&e.push(t)}else if(c.constructor==Object)for(const t in c)r.add(c[t]);else r.add(c);return 0==e.length?r:promiseAll(e).then((()=>r))},setFlatMap=function(t,e){const r=setMap(t,e);return isPromise(r)?r.then(setFlatten):setFlatten(r)},funcConcat=(t,e)=>function(...r){const n=t(...r);return isPromise(n)?n.then(e):e(n)},arrayJoin=(t,e)=>t.join(e),arrayFlattenToString=funcConcat(arrayFlatten,curry2(arrayJoin,__,"")),stringFlatMap=function(t,e){const r=arrayMap(t,e);return isPromise(r)?r.then(arrayFlattenToString):arrayFlattenToString(r)},streamWrite=function(t,e,r,n){return t.write(e,r,n),t},streamFlatExtend=async function(t,e){const r=curry2(streamWrite,t,__),n=funcConcatSync(getArg1,r),o=[];if(isArray(e)){const r=e.length;let n=-1;for(;++n<r;)t.write(e[n])}else if(null==e)t.write(e);else if("function"==typeof e[symbolIterator])for(const r of e)t.write(r);else if("function"==typeof e[symbolAsyncIterator])o.push(asyncIteratorForEach(e[symbolAsyncIterator](),r));else if("function"==typeof e.chain){const n=e.chain(identity);isPromise(n)?o.push(n.then(r)):t.write(n)}else if("function"==typeof e.flatMap){const n=e.flatMap(identity);isPromise(n)?o.push(n.then(r)):t.write(n)}else if("function"==typeof e.reduce){const t=e.reduce(n,null);isPromise(t)&&o.push(t)}else if(e.constructor==Object)for(const r in e)t.write(e[r]);else t.write(e);return 0==o.length?t:promiseAll(o).then(always(t))},streamFlatMap=async function(t,e){const r=new Set;for await(const n of t){const o=e(n);if(isPromise(o)){const e=o.then(curry2(streamFlatExtend,t,__)).then((()=>r.delete(e)));r.add(e)}else{const e=streamFlatExtend(t,o);if(isPromise(e)){const t=e.then((()=>r.delete(t)));r.add(t)}}}return await promiseAll(r),t},globalThisHasBuffer="function"==typeof Buffer,noop=function(){},bufferAlloc=globalThisHasBuffer?Buffer.alloc:noop,_binaryExtend=function(t,e){const r=t.length,n=globalThisHasBuffer&&t.constructor==Buffer?bufferAlloc(r+e.length):new t.constructor(r+e.length);return n.set(t),n.set(e,r),n},binaryExtend=function(t,e){return isArray(e)||isBinary(e)?_binaryExtend(t,e):_binaryExtend(t,[e])},arrayJoinToBinary=function(t,e){const r=t.length;let n=-1,o=e;for(;++n<r;)o=binaryExtend(o,t[n]);return o},arrayFlattenToBinary=function(t,e){const r=arrayFlatten(t);return isPromise(r)?r.then(curry2(arrayJoinToBinary,__,e)):arrayJoinToBinary(r,e)},binaryFlatMap=function(t,e){const r=arrayMap(t,e),n=globalThisHasBuffer&&t.constructor==Buffer?bufferAlloc(0):new t.constructor(0);return isPromise(r)?r.then(curry2(arrayFlattenToBinary,__,n)):arrayFlattenToBinary(r,n)},reducerFlatMap=(t,e)=>function(r,n){const o=e(n);return isPromise(o)?o.then(curryArgs3(genericReduce,__,t,r)):genericReduce([o],t,r)},generatorFunctionFlatMap=(t,e)=>function*(...r){yield*FlatMappingIterator(t(...r),e)},asyncGeneratorFunctionFlatMap=(t,e)=>async function*(...r){yield*FlatMappingAsyncIterator(t(...r),e)},flatMap=t=>function(e){if(isArray(e))return arrayFlatMap(e,t);if("function"==typeof e)return isGeneratorFunction(e)?generatorFunctionFlatMap(e,t):isAsyncGeneratorFunction(e)?asyncGeneratorFunctionFlatMap(e,t):reducerFlatMap(e,t);if(isBinary(e))return binaryFlatMap(e,t);if(null==e)return t(e);if("function"==typeof e.then)return e.then(t);if("function"==typeof e.next)return symbolIterator in e?FlatMappingIterator(e,t):FlatMappingAsyncIterator(e,t);if("function"==typeof e.chain)return e.chain(t);if("function"==typeof e.flatMap)return e.flatMap(t);if("function"==typeof e[symbolAsyncIterator]&&"function"==typeof e.write)return streamFlatMap(e,t);const r=e.constructor;return r==Object?objectFlatMap(e,t):r==Set?setFlatMap(e,t):"string"==typeof e||r==String?stringFlatMap(e,t):t(e)};export default flatMap;
